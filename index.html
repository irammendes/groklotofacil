<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Jogos da Lotofácil - Matrix</title>
    <style>
        body {
            margin: 0;
            background: #000;
            color: #00FF00;
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
        }

        #matrixCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.92;
        }

        .container {
            max-width: 1000px;
            margin: 30px auto;
            background: rgba(0, 0, 0, 0.08);
            padding: 30px;
            border: 2px solid #00FF00;
            border-radius: 10px;
            box-shadow: 0 0 20px #00FF00, 0 0 40px #00FF00;
            animation: glitch 5s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            2%, 4% { transform: translate(2px, -2px); }
            6%, 8% { transform: translate(-2px, 2px); }
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            text-shadow: 0 0 10px #00FF00;
            position: relative;
            overflow: hidden;
        }

        h1::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.3), transparent);
            animation: scan 3s infinite;
        }

        @keyframes scan {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }

        .section {
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.08);
            border: 1px solid #00FF00;
            border-radius: 5px;
            box-shadow: 0 0 10px #00FF00;
        }

        button {
            padding: 12px 24px;
            margin: 10px;
            background: rgba(0, 0, 0, 0.08);
            color: #00FF00;
            border: 2px solid #00FF00;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            text-shadow: 0 0 5px #00FF00;
            transition: all 0.2s;
        }

        button:hover:not(:disabled) {
            background: #00FF00;
            color: #000;
            box-shadow: 0 0 15px #00FF00;
            animation: glitchButton 0.3s;
        }

        #grokButton {
            border: 3px double #00FF00;
            box-shadow: 0 0 20px #00FF00, inset 0 0 10px #00FF00;
            font-weight: bold;
        }

        #grokButton:hover:not(:disabled) {
            background: linear-gradient(45deg, #00FF00, #00B7EB);
            color: #000;
            box-shadow: 0 0 25px #00FF00, inset 0 0 15px #00B7EB;
        }

        @keyframes glitchButton {
            0% { transform: translate(0); }
            50% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        button:disabled {
            border-color: #444;
            color: #444;
            cursor: not-allowed;
            box-shadow: none;
        }

        select {
            padding: 10px;
            margin: 10px;
            background: rgba(0, 0, 0, 0.08);
            color: #00FF00;
            border: 2px solid #00FF00;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
        }

        select option {
            background: #000;
            color: #00FF00;
        }

        #gameResult, #trainingStatus, #updateStatus {
            padding: 15px;
            margin: 10px 0;
            border: 1px solid #00FF00;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.08);
            box-shadow: 0 0 10px #00FF00;
        }

        #gameResult.success { border-color: #00FF00; color: #00FF00; }
        #updateStatus.error { border-color: #FF0000; color: #FF0000; box-shadow: 0 0 10px #FF0000; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid #00FF00;
        }

        th {
            background: rgba(0, 68, 0, 0.08);
            color: #00FF00;
            text-shadow: 0 0 5px #00FF00;
        }

        td {
            background: rgba(0, 0, 0, 0.08);
        }

        .hot { background: rgba(255, 0, 0, 0.3); color: #FF0000; box-shadow: 0 0 10px #FF0000; }
        .cold { background: rgba(0, 0, 255, 0.3); color: #00B7EB; box-shadow: 0 0 10px #00B7EB; }

        canvas {
            margin-top: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.08);
            border: 1px solid #00FF00;
            border-radius: 5px;
            box-shadow: 0 0 10px #00FF00;
        }

        #progressContainer, #loadingContainer {
            display: none;
            margin: 20px 0;
            text-align: center;
        }

        progress {
            width: 100%;
            height: 30px;
            border: 2px solid #00FF00;
            background: #000;
            border-radius: 5px;
        }

        progress::-webkit-progress-bar {
            background: #000;
        }

        progress::-webkit-progress-value {
            background: #00FF00;
            border-radius: 3px;
            box-shadow: 0 0 10px #00FF00;
        }

        progress::-moz-progress-bar {
            background: #00FF00;
            border-radius: 3px;
            box-shadow: 0 0 10px #00FF00;
        }

        @media (max-width: 600px) {
            .container { padding: 15px; }
            h1 { font-size: 1.8em; }
            button, select { width: 100%; margin: 5px 0; }
        }
    </style>
</head>
<body>
    <canvas id="matrixCanvas"></canvas>
    <div class="container">
        <h1>Gerador de Jogos da Lotofácil - Matrix</h1>
        <div class="section">
            <label for="numCount">Quantidade de Números:</label>
            <select id="numCount">
                <option value="15">15 (Aposta Simples)</option>
                <option value="16">16 (Desdobramento)</option>
                <option value="17">17 (Desdobramento)</option>
                <option value="18">18 (Desdobramento)</option>
                <option value="19">19 (Desdobramento)</option>
                <option value="20">20 (Desdobramento)</option>
            </select>
            <label for="strategy">Estratégia:</label>
            <select id="strategy">
                <option value="combined">Combinado (Todas)</option>
                <option value="evensOdds">Equilíbrio Pares/Ímpares</option>
                <option value="primes">Números Primos</option>
                <option value="hotCold">Números Quentes/Atrasados</option>
                <option value="noSequences">Evitar Sequências</option>
            </select>
            <label for="gameCount">Quantidade de Jogos:</label>
            <select id="gameCount">
                <option value="1">1 Jogo</option>
                <option value="2">2 Jogos</option>
                <option value="3">3 Jogos</option>
                <option value="4">4 Jogos</option>
                <option value="5">5 Jogos</option>
                <option value="6">6 Jogos</option>
                <option value="7">7 Jogos</option>
                <option value="8">8 Jogos</option>
                <option value="9">9 Jogos</option>
                <option value="10">10 Jogos</option>
            </select>
            <button id="generateButton" onclick="generateGame()" disabled>Gerar Jogo</button>
            <button id="bolaoButton" onclick="generateBolao()" disabled>Gerar Bolão</button>
            <button id="grokButton" onclick="grokGenerate()" disabled>Grok</button>
            <button id="trainButton" onclick="trainAI()" disabled>Treinar IA</button>
            <button id="updateButton" onclick="updateResults()">Atualizar Resultados</button>
        </div>
        <div id="loadingContainer">
            <p id="loadingText">Carregando dados...</p>
            <progress id="loadingProgress" value="0" max="100"></progress>
        </div>
        <div id="progressContainer">
            <p>Treinando IA...</p>
            <progress id="trainingProgress" value="0" max="100"></progress>
        </div>
        <div id="gameResult">Jogo gerado aparecerá aqui.</div>
        <div id="trainingStatus">Status do treinamento: Não treinado.</div>
        <div id="updateStatus">Última atualização: Aguardando carregamento inicial...</div>
        <div class="section">
            <h2>Números Quentes e Atrasados</h2>
            <table id="statsTable">
                <thead>
                    <tr>
                        <th>Número</th>
                        <th>Frequência</th>
                        <th>Sorteios sem Sair</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
        <div class="section">
            <h2>Gráfico de Probabilidade dos Números</h2>
            <canvas id="probabilityChart"></canvas>
        </div>
        <div class="section">
            <h2>Gráfico de Confiança da IA</h2>
            <canvas id="confidenceChart"></canvas>
        </div>
        <div class="section">
            <h2>Gráfico de Frequência (Quentes/Atrasados)</h2>
            <canvas id="frequencyChart"></canvas>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Chuva de código Matrix
        const canvas = document.getElementById('matrixCanvas');
        const ctx = canvas.getContext('2d');
        canvas.height = window.innerHeight;
        canvas.width = window.innerWidth;

        const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZあいうえおカキクケコ';
        const fontSize = 14;
        const columns = Math.floor(canvas.width / fontSize);
        const drops = Array(columns).fill(1);
        let animationFrameId;

        function drawMatrix() {
            if (document.hidden) {
                animationFrameId = requestAnimationFrame(drawMatrix);
                return;
            }
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00FF00';
            ctx.font = `${fontSize}px monospace`;

            for (let i = 0; i < drops.length; i++) {
                const text = chars.charAt(Math.floor(Math.random() * chars.length));
                const x = i * fontSize;
                const y = drops[i] * fontSize;
                ctx.fillText(text, x, y);

                if (y > canvas.height && Math.random() > 0.975) drops[i] = 0;
                drops[i]++;
            }
            animationFrameId = requestAnimationFrame(drawMatrix);
        }

        function startMatrix() {
            if (!animationFrameId) {
                drawMatrix();
            }
        }

        function stopMatrix() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        document.addEventListener('visibilitychange', () => {
            document.hidden ? stopMatrix() : startMatrix();
        });

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                canvas.height = window.innerHeight;
                canvas.width = window.innerWidth;
                drops.length = Math.floor(canvas.width / fontSize);
                drops.fill(1);
            }, 200);
        });

        startMatrix();

        // Estado inicial
        let historicalResults = [];
        const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23];
        let probabilities = Array(25).fill(1 / 25);
        let frequencies = Array(25).fill(0);
        let lastDrawn = Array(25).fill(0);
        let confidence = 0;
        let isTrained = false;

        // URLs da API
        const API_PRIMARY = 'https://loteriascaixa-api.herokuapp.com/api/lotofacil';
        const API_FALLBACK = 'https://loterias.caixa.gov.br/loterias/api/lotofacil';

        // Cache de resultados
        function loadCache() {
            const cached = localStorage.getItem('lotofacilCache');
            return cached ? JSON.parse(cached) : null;
        }

        function saveCache(data) {
            localStorage.setItem('lotofacilCache', JSON.stringify(data));
        }

        // Função para buscar resultados
        async function fetchResults(contestNumber = null, retryCount = 0) {
            let url = retryCount > 0 ? API_FALLBACK : API_PRIMARY;
            if (contestNumber) {
                url += `/${contestNumber}`;
            }
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                const response = await fetch(url, {
                    headers: { 'Accept': 'application/json' },
                    signal: controller.signal,
                    mode: 'cors'
                });
                clearTimeout(timeoutId);
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                const data = await response.json();
                let numbers = Array.isArray(data) ? data[0].dezenas : data.dezenas || data.listaDezenas;
                if (!numbers || !Array.isArray(numbers)) {
                    throw new Error('Formato de dados inválido');
                }
                return {
                    numero: data.numero || data.concurso || (Array.isArray(data) ? data[0].concurso : data.concurso),
                    dataApuracao: data.data || data.dataApuracao || (Array.isArray(data) ? data[0].data : data.data),
                    listaDezenas: numbers.map(n => n.toString().padStart(2, '0'))
                };
            } catch (error) {
                if (retryCount < 2) {
                    const delay = Math.pow(2, retryCount) * 1000;
                    console.warn(`Tentativa ${retryCount + 1} falhou: ${error.message}. Tentando novamente após ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchResults(contestNumber, retryCount + 1);
                }
                throw new Error(`API indisponível: ${error.message}`);
            }
        }

        // Carregar resultados históricos
        async function loadHistoricalResults() {
            const loadingContainer = document.getElementById('loadingContainer');
            const loadingProgress = document.getElementById('loadingProgress');
            const loadingText = document.getElementById('loadingText');
            loadingContainer.style.display = 'block';
            toggleButtons(false);

            try {
                let cached = loadCache();
                if (cached && cached.latest && cached.results) {
                    historicalResults = cached.results;
                    document.getElementById('updateStatus').innerText = `Última atualização: Concurso ${cached.latest.numero} (${cached.latest.dataApuracao})`;
                    calculateStats();
                    toggleButtons(true);
                    updateProbabilityChart();
                    updateFrequencyChart();
                    loadingContainer.style.display = 'none';
                    return;
                }

                const latest = await fetchResults();
                const latestContest = parseInt(latest.numero);
                loadingText.innerText = `Carregando concurso ${latestContest}...`;
                loadingProgress.value = 10;

                historicalResults = [];
                const maxContests = 3;
                let successfulLoads = 0;

                for (let i = 0; i < maxContests; i++) {
                    const contestNumber = latestContest - i;
                    loadingText.innerText = `Carregando concurso ${contestNumber} (${i + 1}/${maxContests})...`;
                    loadingProgress.value = ((i + 1) / maxContests) * 90 + 10;
                    try {
                        const data = await fetchResults(contestNumber);
                        historicalResults.push(data.listaDezenas.map(n => parseInt(n)));
                        successfulLoads++;
                    } catch (error) {
                        console.warn(`Erro ao carregar concurso ${contestNumber}:`, error);
                    }
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                if (successfulLoads > 0) {
                    document.getElementById('updateStatus').innerText = `Última atualização: Concurso ${latestContest} (${latest.dataApuracao})`;
                    document.getElementById('updateStatus').classList.remove('error');
                    saveCache({ latest, results: historicalResults });
                    calculateStats();
                    toggleButtons(true);
                    updateProbabilityChart();
                    updateFrequencyChart();
                } else {
                    // Fallback para dados simulados
                    historicalResults = [
                        [1, 3, 5, 7, 9, 10, 12, 13, 15, 17, 19, 20, 22, 24, 25],
                        [2, 4, 6, 8, 10, 11, 13, 15, 16, 18, 20, 21, 23, 24, 25],
                        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
                    ];
                    document.getElementById('updateStatus').innerText = `Usando dados simulados (API indisponível)`;
                    calculateStats();
                    toggleButtons(true);
                    updateProbabilityChart();
                    updateFrequencyChart();
                }
            } catch (error) {
                document.getElementById('updateStatus').innerText = `Erro: Falha ao conectar com a API. Usando dados simulados. (${error.message})`;
                document.getElementById('updateStatus').classList.add('error');
                historicalResults = [
                    [1, 3, 5, 7, 9, 10, 12, 13, 15, 17, 19, 20, 22, 24, 25],
                    [2, 4, 6, 8, 10, 11, 13, 15, 16, 18, 20, 21, 23, 24, 25],
                    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
                ];
                calculateStats();
                toggleButtons(true);
                updateProbabilityChart();
                updateFrequencyChart();
            } finally {
                loadingContainer.style.display = 'none';
            }
        }

        // Calcular estatísticas
        function calculateStats() {
            frequencies = Array(25).fill(0);
            lastDrawn = Array(25).fill(historicalResults.length || 1);
            historicalResults.forEach((result, index) => {
                result.forEach(num => {
                    frequencies[num - 1]++;
                    lastDrawn[num - 1] = Math.min(lastDrawn[num - 1], historicalResults.length - index - 1);
                });
            });
            let totalNumbers = historicalResults.length * 15 || 25;
            probabilities = frequencies.map(freq => freq / totalNumbers || 0.01);
            let sum = probabilities.reduce((a, b) => a + b, 0);
            probabilities = probabilities.map(p => p / sum || 0.04);
            updateStatsTable();
        }

        // Avaliar jogo conforme estratégia selecionada
        function evaluateGame(numbers, strategy) {
            let score = 0;
            let evens = numbers.filter(n => n % 2 === 0).length;
            let odds = numbers.length - evens;
            let primeCount = numbers.filter(n => primes.includes(n)).length;
            let hasSequence = false;
            for (let i = 1; i < numbers.length - 1; i++) {
                if (numbers[i] - numbers[i - 1] === 1 && numbers[i + 1] - numbers[i] === 1) {
                    hasSequence = true;
                    break;
                }
            }
            let top10 = frequencies.map((f, i) => ({ num: i + 1, freq: f }))
                .sort((a, b) => b.freq - a.freq).slice(0, 10).map(x => x.num);
            let hotCount = numbers.filter(n => top10.includes(n)).length;

            if (strategy === 'evensOdds') {
                if ((evens >= 7 && evens <= 8) || (odds >= 7 && odds <= 8)) score += 100;
            } else if (strategy === 'primes') {
                if (primeCount >= 4 && primeCount <= 6) score += 100;
            } else if (strategy === 'hotCold') {
                if (hotCount >= 5) score += 100;
            } else if (strategy === 'noSequences') {
                if (!hasSequence) score += 100;
            } else { // combined
                if ((evens >= 7 && evens <= 8) || (odds >= 7 && odds <= 8)) score += 40;
                if (primeCount >= 4 && primeCount <= 6) score += 30;
                if (!hasSequence) score += 20;
                if (hotCount >= 5) score += 10;
            }

            return { score, evens, odds, primeCount };
        }

        // Gerar jogo
        async function generateGame() {
            toggleButtons(false);
            let numCount = parseInt(document.getElementById('numCount').value);
            let strategy = document.getElementById('strategy').value;
            let bestGame = null;
            let bestScore = -1;

            calculateStats();

            for (let i = 0; i < 50; i++) {
                let numbers = [];
                let tempProbs = [...probabilities];
                let top10 = frequencies.map((f, i) => ({ num: i + 1, freq: f }))
                    .sort((a, b) => b.freq - a.freq).slice(0, 10).map(x => x.num);
                let cold = lastDrawn.map((d, i) => ({ num: i + 1, draws: d }))
                    .sort((a, b) => b.draws - a.draws).slice(0, 5).map(x => x.num);

                let baseNumbers = strategy === 'hotCold' || strategy === 'combined'
                    ? [...new Set([...top10.slice(0, 5), ...cold.slice(0, 1)])]
                    : [];
                numbers.push(...baseNumbers);
                tempProbs = tempProbs.map((p, idx) => numbers.includes(idx + 1) ? 0 : p);

                while (numbers.length < numCount) {
                    let cumulative = 0;
                    let random = Math.random();
                    for (let j = 0; j < tempProbs.length; j++) {
                        cumulative += tempProbs[j];
                        if (random <= cumulative && !numbers.includes(j + 1)) {
                            numbers.push(j + 1);
                            tempProbs[j] = 0;
                            break;
                        }
                    }
                }

                let isRepeated = historicalResults.some(result =>
                    result.length === numbers.length &&
                    result.every(num => numbers.includes(num))
                );
                if (isRepeated) continue;

                numbers.sort((a, b) => a - b);
                let evalResult = evaluateGame(numbers, strategy);
                if (evalResult.score > bestScore) {
                    bestScore = evalResult.score;
                    bestGame = { numbers, ...evalResult };
                }
            }

            if (bestGame) {
                document.getElementById('gameResult').innerHTML = `
                    <strong>Jogo Gerado:</strong> ${bestGame.numbers.join(', ')}<br>
                    <strong>Detalhes:</strong> ${bestGame.evens} pares, ${bestGame.odds} ímpares, 
                    ${bestGame.primeCount} primos, Score: ${bestScore}/100
                `;
                document.getElementById('gameResult').classList.add('success');
            } else {
                document.getElementById('gameResult').innerText = 'Não foi possível gerar um jogo único. Tente novamente.';
                document.getElementById('gameResult').classList.remove('success');
            }
            updateProbabilityChart();
            updateFrequencyChart();
            toggleButtons(true);
        }

        // Gerar bolão
        async function generateBolao() {
            toggleButtons(false);
            let numCount = parseInt(document.getElementById('numCount').value);
            let gameCount = parseInt(document.getElementById('gameCount').value);
            let strategy = document.getElementById('strategy').value;
            let games = [];

            try {
                calculateStats();

                for (let i = 0; i < gameCount; i++) {
                    let numbers = [];
                    let tempProbs = [...probabilities];
                    let top10 = frequencies.map((f, i) => ({ num: i + 1, freq: f }))
                        .sort((a, b) => b.freq - a.freq).slice(0, 10).map(x => x.num);
                    let cold = lastDrawn.map((d, i) => ({ num: i + 1, draws: d }))
                        .sort((a, b) => b.draws - a.draws).slice(0, 5).map(x => x.num);

                    let baseNumbers = [...new Set([...top10.slice(0, 5), ...cold.slice(0, 1)])];
                    numbers.push(...baseNumbers);
                    tempProbs = tempProbs.map((p, idx) => numbers.includes(idx + 1) ? 0 : p);

                    let maxAttempts = 50;
                    let attempt = 0;

                    while (numbers.length < numCount && attempt < maxAttempts) {
                        let cumulative = 0;
                        let random = Math.random();
                        for (let j = 0; j < tempProbs.length; j++) {
                            cumulative += tempProbs[j];
                            if (random <= cumulative && !numbers.includes(j + 1)) {
                                numbers.push(j + 1);
                                tempProbs[j] = 0;
                                break;
                            }
                        }
                        attempt++;
                    }

                    if (numbers.length < numCount) {
                        while (numbers.length < numCount) {
                            let num = Math.floor(Math.random() * 25) + 1;
                            if (!numbers.includes(num)) numbers.push(num);
                        }
                    }

                    numbers.sort((a, b) => a - b);
                    let isRepeated = games.some(g => g.numbers.every(n => numbers.includes(n))) ||
                                    historicalResults.some(r => r.length === numbers.length && r.every(n => numbers.includes(n)));
                    if (!isRepeated) {
                        let evalResult = evaluateGame(numbers, strategy);
                        games.push({ numbers, score: evalResult.score, evens: evalResult.evens, odds: evalResult.odds, primeCount: evalResult.primeCount });
                    } else {
                        if (i > 0) i--;
                    }
                }

                if (games.length === 0) {
                    throw new Error('Não foi possível gerar jogos únicos.');
                }

                document.getElementById('gameResult').innerHTML = `
                    <strong>Bolão Gerado (${games.length} jogos):</strong><br>
                    ${games.map((g, i) => {
                        let gameConfidence = confidence * (0.9 + 0.1 * (g.score / 100));
                        return `Jogo ${i + 1}: ${g.numbers.join(', ')} - Confiança: ${(gameConfidence * 100).toFixed(2)}%<br>
                                  Detalhes: ${g.evens} pares, ${g.odds} ímpares, ${g.primeCount} primos, Score: ${g.score}/100`;
                    }).join('<br>')}
                `;
                document.getElementById('gameResult').classList.add('success');
            } catch (error) {
                document.getElementById('gameResult').innerText = `Erro ao gerar bolão: ${error.message}. Tente novamente.`;
                document.getElementById('gameResult').classList.remove('success');
                console.error('Erro em generateBolao:', error);
            }

            updateProbabilityChart();
            updateFrequencyChart();
            toggleButtons(true);
        }

        // Gerar jogos com Grok
        async function grokGenerate() {
            toggleButtons(false);
            let numCount = 15;
            let gameCount = 5;
            let strategy = 'combined';
            let games = [];

            try {
                calculateStats();
                document.getElementById('gameResult').innerHTML = `
                    <strong>Processando conhecimento de Grok...</strong><br>
                    <span style="color: #00B7EB;">Analisando ciclos, frequências e padrões históricos...</span>
                `;
                await new Promise(resolve => setTimeout(resolve, 1000)); // Efeito visual

                for (let i = 0; i < gameCount; i++) {
                    let numbers = [];
                    let tempProbs = [...probabilities];
                    let top10 = frequencies.map((f, i) => ({ num: i + 1, freq: f }))
                        .sort((a, b) => b.freq - a.freq).slice(0, 10).map(x => x.num);
                    let cold = lastDrawn.map((d, i) => ({ num: i + 1, draws: d }))
                        .sort((a, b) => b.draws - a.draws).slice(0, 5).map(x => x.num);

                    let baseNumbers = [...new Set([...top10.slice(0, 6), ...cold.slice(0, 2)])];
                    numbers.push(...baseNumbers);
                    tempProbs = tempProbs.map((p, idx) => numbers.includes(idx + 1) ? 0 : p);

                    let maxAttempts = 50;
                    let attempt = 0;

                    while (numbers.length < numCount && attempt < maxAttempts) {
                        let cumulative = 0;
                        let random = Math.random();
                        for (let j = 0; j < tempProbs.length; j++) {
                            cumulative += tempProbs[j];
                            if (random <= cumulative && !numbers.includes(j + 1)) {
                                numbers.push(j + 1);
                                tempProbs[j] = 0;
                                break;
                            }
                        }
                        attempt++;
                    }

                    if (numbers.length < numCount) {
                        while (numbers.length < numCount) {
                            let num = Math.floor(Math.random() * 25) + 1;
                            if (!numbers.includes(num)) numbers.push(num);
                        }
                    }

                    numbers.sort((a, b) => a - b);
                    let isRepeated = games.some(g => g.numbers.every(n => numbers.includes(n))) ||
                                    historicalResults.some(r => r.length === numbers.length && r.every(n => numbers.includes(n)));
                    if (!isRepeated) {
                        let evalResult = evaluateGame(numbers, strategy);
                        games.push({ numbers, score: evalResult.score, evens: evalResult.evens, odds: evalResult.odds, primeCount: evalResult.primeCount });
                    } else {
                        if (i > 0) i--;
                    }
                }

                if (games.length === 0) {
                    throw new Error('Não foi possível gerar jogos únicos.');
                }

                document.getElementById('gameResult').innerHTML = `
                    <strong>Grok's Ultimate Bolão (${games.length} jogos):</strong><br>
                    <span style="color: #00B7EB;">Gerado com base em análise avançada de Grok!</span><br>
                    ${games.map((g, i) => {
                        let gameConfidence = confidence * (0.9 + 0.1 * (g.score / 100));
                        return `Jogo ${i + 1}: ${g.numbers.join(', ')} - Confiança: ${(gameConfidence * 100).toFixed(2)}%<br>
                                  Detalhes: ${g.evens} pares, ${g.odds} ímpares, ${g.primeCount} primos, Score: ${g.score}/100`;
                    }).join('<br>')}
                `;
                document.getElementById('gameResult').classList.add('success');
            } catch (error) {
                document.getElementById('gameResult').innerText = `Erro ao gerar bolão Grok: ${error.message}. Tente novamente.`;
                document.getElementById('gameResult').classList.remove('success');
                console.error('Erro em grokGenerate:', error);
            }

            updateProbabilityChart();
            updateFrequencyChart();
            toggleButtons(true);
        }

        // Treinar IA com barra de progresso
        async function trainAI() {
            toggleButtons(false);
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('trainingProgress');
            progressContainer.style.display = 'block';
            progressBar.value = 0;

            for (let i = 0; i <= 100; i += 10) {
                await new Promise(resolve => setTimeout(resolve, 200));
                progressBar.value = i;
            }

            calculateStats();
            let totalNumbers = historicalResults.length * 15 || 25;
            let actualFrequencies = frequencies.map(f => f / totalNumbers);

            let l1Error = 0;
            let l2Error = 0;
            for (let i = 0; i < 25; i++) {
                let error = Math.abs(probabilities[i] - actualFrequencies[i]);
                l1Error += error;
                l2Error += error * error;
            }
            l1Error /= 25;
            l2Error /= 25;

            let l1Normalized = Math.max(0, 1 - l1Error * 100);
            let l2Normalized = Math.max(0, 1 - l2Error * 1000);
            confidence = 0.9 + 0.05 * (l1Normalized + l2Normalized) / 2;
            confidence = Math.min(0.95, Math.max(0.9, confidence));

            isTrained = true;
            document.getElementById('trainingStatus').innerText = 
                `Status do treinamento: Treinado (Confiança: ${(confidence * 100).toFixed(2)}%, MAE: ${l1Error.toFixed(4)}, MSE: ${l2Error.toFixed(4)})`;
            updateConfidenceChart();
            progressContainer.style.display = 'none';
            toggleButtons(true);
        }

        // Atualizar resultados
        async function updateResults() {
            toggleButtons(false);
            try {
                const latest = await fetchResults();
                const latestNumbers = latest.listaDezenas.map(n => parseInt(n));
                if (!historicalResults.some(r => r.every((n, i) => n === latestNumbers[i]))) {
                    historicalResults.unshift(latestNumbers);
                    document.getElementById('updateStatus').innerText = `Última atualização: Concurso ${latest.numero} (${latest.dataApuracao})`;
                    document.getElementById('updateStatus').classList.remove('error');
                    saveCache({ latest, results: historicalResults });
                    if (isTrained) await trainAI();
                    updateProbabilityChart();
                    updateFrequencyChart();
                } else {
                    document.getElementById('updateStatus').innerText = `Última atualização: Concurso ${latest.numero} (já atualizado)`;
                    document.getElementById('updateStatus').classList.remove('error');
                }
            } catch (error) {
                document.getElementById('updateStatus').innerText = `Erro ao atualizar: ${error.message}. Tente novamente.`;
                document.getElementById('updateStatus').classList.add('error');
            }
            toggleButtons(true);
        }

        // Atualizar tabela de estatísticas
        function updateStatsTable() {
            let tbody = document.querySelector('#statsTable tbody');
            tbody.innerHTML = '';
            for (let i = 0; i < 25; i++) {
                let row = document.createElement('tr');
                let isHot = frequencies[i] > (historicalResults.length * 15 / 25) * 1.2;
                let isCold = lastDrawn[i] > 5;
                row.className = isHot ? 'hot' : isCold ? 'cold' : '';
                row.innerHTML = `
                    <td>${i + 1}</td>
                    <td>${frequencies[i]}</td>
                    <td>${lastDrawn[i]}</td>
                `;
                tbody.appendChild(row);
            }
        }

        // Configuração dos gráficos
        const probabilityChart = new Chart(document.getElementById('probabilityChart'), {
            type: 'bar',
            data: {
                labels: Array.from({length: 25}, (_, i) => i + 1),
                datasets: [{
                    label: 'Probabilidade (%)',
                    data: probabilities.map(p => (p * 100).toFixed(2)),
                    backgroundColor: 'rgba(0, 255, 0, 0.5)',
                    borderColor: '#00FF00',
                    borderWidth: 2
                }]
            },
            options: {
                animation: { duration: 1000, easing: 'easeOutQuart' },
                scales: {
                    y: { beginAtZero: true, title: { display: true, text: 'Probabilidade (%)', color: '#00FF00' }, ticks: { color: '#00FF00' }, grid: { color: '#004400' } },
                    x: { title: { display: true, text: 'Número', color: '#00FF00' }, ticks: { color: '#00FF00' }, grid: { color: '#004400' } }
                },
                plugins: { legend: { labels: { color: '#00FF00' } } }
            }
        });

        const confidenceChart = new Chart(document.getElementById('confidenceChart'), {
            type: 'line',
            data: {
                labels: ['Inicial', 'Após Treinamento'],
                datasets: [{
                    label: 'Confiança da IA (%)',
                    data: [0, confidence * 100],
                    borderColor: '#00FF00',
                    backgroundColor: 'rgba(0, 255, 0, 0.2)',
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                animation: { duration: 1000, easing: 'easeOutQuart' },
                scales: {
                    y: { beginAtZero: true, max: 100, title: { display: true, text: 'Confiança (%)', color: '#00FF00' }, ticks: { color: '#00FF00' }, grid: { color: '#004400' } },
                    x: { title: { display: true, text: 'Etapa', color: '#00FF00' }, ticks: { color: '#00FF00' }, grid: { color: '#004400' } }
                },
                plugins: { legend: { labels: { color: '#00FF00' } } }
            }
        });

        const frequencyChart = new Chart(document.getElementById('frequencyChart'), {
            type: 'bar',
            data: {
                labels: Array.from({length: 25}, (_, i) => i + 1),
                datasets: [
                    {
                        label: 'Frequência',
                        data: frequencies,
                        backgroundColor: 'rgba(0, 255, 0, 0.5)',
                        borderColor: '#00FF00',
                        borderWidth: 2
                    },
                    {
                        label: 'Sorteios sem Sair',
                        data: lastDrawn,
                        backgroundColor: 'rgba(0, 183, 235, 0.5)',
                        borderColor: '#00B7EB',
                        borderWidth: 2
                    }
                ]
            },
            options: {
                animation: { duration: 1000, easing: 'easeOutQuart' },
                scales: {
                    y: { beginAtZero: true, title: { display: true, text: 'Quantidade', color: '#00FF00' }, ticks: { color: '#00FF00' }, grid: { color: '#004400' } },
                    x: { title: { display: true, text: 'Número', color: '#00FF00' }, ticks: { color: '#00FF00' }, grid: { color: '#004400' } }
                },
                plugins: { legend: { labels: { color: '#00FF00' } } }
            }
        });

        // Atualizar gráficos
        function updateProbabilityChart() {
            probabilityChart.data.datasets[0].data = probabilities.map(p => (p * 100).toFixed(2));
            probabilityChart.update();
        }

        function updateConfidenceChart() {
            confidenceChart.data.datasets[0].data = [0, confidence * 100];
            confidenceChart.update();
        }

        function updateFrequencyChart() {
            frequencyChart.data.datasets[0].data = frequencies;
            frequencyChart.data.datasets[1].data = lastDrawn;
            frequencyChart.update();
        }

        // Controlar botões
        function toggleButtons(enable) {
            document.getElementById('generateButton').disabled = !enable;
            document.getElementById('bolaoButton').disabled = !enable;
            document.getElementById('grokButton').disabled = !enable;
            document.getElementById('trainButton').disabled = !enable;
            document.getElementById('updateButton').disabled = !enable;
        }

        // Formatação numérica
        Number.prototype.toFixed_fm = function(digits) {
            return this.toFixed(digits).replace(/\.?0+$/, '');
        };

        // Inicializar
        loadHistoricalResults();
    </script>
</body>
</html>
